# PyRecipe

一个优雅的Python菜谱定义框架，使用中文命名，支持自动生成Markdown格式的菜谱文档。

## 特性

- **统一抽象**: 所有食材、中间产物、最终菜品都抽象为`食材组件`对象
- **Pythonic设计**: 装饰器、上下文管理器、操作符重载、中文命名
- **类型安全**: 完整的类型注解，Protocol-based接口
- **强扩展性**: 插件化的处理器系统，支持多种输出格式
- **菜谱复用**: 轻松引用和组合已定义的菜谱

## 快速开始

### 定义菜谱（推荐使用装饰器）

```python
from 菜谱框架 import *

@定义菜谱("番茄炒蛋")
def 番茄炒蛋(菜: 菜谱构建器):
    番茄 = 菜.切(菜.取食材("番茄", 个(2)), "块")
    鸡蛋 = 菜.取食材("鸡蛋", 个(3))
    葱 = 菜.切(菜.取食材("葱", 根(1)), "段")
    盐 = 菜.取食材("盐", 克(3))

    炒蛋 = 菜.炒([鸡蛋], 时间_秒=30, 描述="炒", 用油=10, 名称="炒鸡蛋")
    炒番茄 = 菜.炒([番茄], 时间_秒=20, 描述="炒", 用油=5, 名称="炒番茄")
    混合 = 菜.混合([炒蛋, 炒番茄], "翻炒均匀")
    最终 = 菜.调味([混合], ["葱", "盐"], "加入盐和葱花")

    return 最终
```

### 生成Markdown菜谱

```python
from 菜谱框架 import 预览菜谱, 生成菜谱文档, 生成所有菜谱

# 预览菜谱（控制台输出）
预览菜谱("番茄炒蛋")

# 生成单个菜谱文件
生成菜谱文档("番茄炒蛋", "菜谱/番茄炒蛋.md")

# 批量生成所有已注册菜谱
生成所有菜谱(输出目录="菜谱文档")
```

## 核心概念

### 食材组件

所有食材、中间产物、最终菜品都统一抽象为`食材组件`：

```python
@dataclass(slots=True)
class 食材组件:
    name: str
    id: int  # 自动递增
    数量: Optional[数量类型] = None
    子组件: List[食材组件]
    元数据: Dict[str, Any]
    操作: Optional[烹饪操作] = None
    是否基础食材: bool = False
```

### 数量类型

```python
克(500)      # 500克
个(2)        # 2个
片(3)        # 3片
根(1)        # 1根
毫升(100)    # 100毫升
自定义单位("1勺")  # 自定义描述
```

### 烹饪操作

```python
切("块")           # 切割
混合("拌匀")       # 混合
炒(30, "中火")     # 炒30秒
炖(120, "小火")    # 炖120秒
```

### 处理器

处理器负责将菜谱转换为不同的输出格式：

- **Markdown输出器**: 生成Markdown格式的烹饪步骤
- **统计分析器**: 统计食材用量
- **组合处理器**: 同时使用多个处理器

## 菜谱定义风格

### 1. 装饰器风格（推荐）

```python
@定义菜谱("意大利肉酱")
def 意大利肉酱(菜: 菜谱构建器):
    芹菜段 = 菜.切(菜.取食材("芹菜", 根(1)), "段")
    猪肉碎 = 菜.切(菜.取食材("猪肉", 克(600)), "碎")
    洋葱丁 = 菜.切(菜.取食材("洋葱", 个(1)), "碎")
    番茄酱 = 菜.取食材("番茄酱", 克(100))

    return 菜.混合([芹菜段, 猪肉碎, 洋葱丁, 番茄酱],
                  "混合，下锅翻炒一分钟",
                  "意大利肉酱")
```

### 2. 上下文管理器风格

```python
with 菜谱上下文(Markdown输出器()) as 菜:
    芹菜段 = 菜.切(菜.取食材("芹菜", 根(1)), "段")
    猪肉碎 = 菜.切(菜.取食材("猪肉", 克(600)), "碎")
    肉酱 = 菜.混合([芹菜段, 猪肉碎, ...], "混合，下锅翻炒一分钟")
```

### 3. 操作符重载风格

```python
芹菜段 = 菜.取食材("芹菜", 根(1)) >> 切("段")
猪肉碎 = 菜.取食材("猪肉", 克(600)) >> 切("碎")
肉酱 = (芹菜段 + 猪肉碎 + 洋葱丁) >> 混合("混合")
```

## 菜谱复用

```python
@定义菜谱("意大利肉酱三明治")
def 意大利肉酱三明治(菜: 菜谱构建器):
    面包片 = 菜.取食材("面包片", 片(2))
    # 引用已定义的菜谱
    肉酱 = 菜.引用("意大利肉酱")

    return 菜.组合([面包片, 肉酱], "夹在一起", "意大利肉酱三明治")
```

## 框架结构

```
菜谱框架/
├── __init__.py              # 框架入口
├── 核心组件.py              # 食材组件、数量类型、烹饪操作
├── 处理器.py                # 处理器协议和实现
├── 构建器.py                # 菜谱构建器
├── 装饰器.py                # 装饰器和注册表
└── markdown生成器.py        # Markdown文档生成器
```

## 运行示例

```bash
# 基础示例（展示所有定义风格）
python 示例/基础示例.py

# 完整菜谱示例
python 示例/完整菜谱.py

# Markdown生成示例
python 示例/生成markdown菜谱.py

# 简单测试
python 简单测试.py
```

## 生成的Markdown示例

```markdown
# 番茄炒蛋

## 食材清单

- **番茄**: 2个
- **鸡蛋**: 3个
- **葱**: 1根
- **盐**: 3克

## 烹饪步骤

1. 将 2个 的 番茄 切成块
2. 将 1根 的 葱 切成段
3. 将 鸡蛋 炒30秒，用10克油，炒
4. 将 番茄 炒20秒，用5克油，炒
5. 将 炒鸡蛋, 番茄 翻炒均匀
6. 将 混合好的 加入葱, 盐

---

## 备注

- 本菜谱由Pythonic菜谱框架自动生成
```

## 技术亮点

- **不可变数据**: `@dataclass(frozen=True, slots=True)`
- **Protocol**: 类型安全的鸭子类型
- **操作符重载**: `+`, `>>`, `&` 使代码更直观
- **装饰器注册**: `@定义菜谱` 自动注册菜谱
- **上下文管理器**: `with 菜谱上下文` 优雅语法

## 扩展框架

### 自定义处理器

实现`菜谱处理器`协议：

```python
class RobotProcessor:
    def 取食材(self, 名称: str, 数量: 数量类型) -> 食材组件:
        # 生成机器人指令
        ...

    def 处理(self, 组件: List[食材组件], 操作: 烹饪操作, 名称: str, **元数据) -> 食材组件:
        # 生成处理指令
        ...
```

### 自定义数量类型

```python
@dataclass(frozen=True, slots=True)
class 杯(数量类型):
    def __post_init__(self):
        object.__setattr__(self, 'unit', '杯')
```

## 设计原则

- **统一抽象**: 一切皆食材组件
- **高度可扩展**: Protocol-based处理器系统
- **类型安全**: 完整的类型注解
- **简洁**: 函数式风格，最小化冗余
- **Pythonic**: 充分利用Python特性

## 许可证

MIT License
