# Pythonic菜谱框架 v2.0

一个更加Pythonic的菜谱定义框架，使用中文命名，提供简洁优雅的API。

## 特性

✅ **更Pythonic**: 使用装饰器、上下文管理器、操作符重载
✅ **中文命名**: 类和方法使用项目相关的中文/拼音名称
✅ **简洁API**: 多种定义风格，减少样板代码
✅ **类型安全**: 完整的类型注解，支持IDE智能提示
✅ **强扩展性**: 插件系统、装饰器注册
✅ **菜谱复用**: 轻松引用和组合已定义的菜谱

## 快速开始

### 安装

```bash
# 将框架复制到项目目录
cd program_recipe
```

### 基础用法

#### 1. 装饰器风格（推荐）

```python
from 菜谱框架 import *

@定义菜谱("意大利肉酱")
def 意大利肉酱(菜: 菜谱构建器):
    芹菜段 = 菜.切(菜.取食材("芹菜", 根(1)), "段")
    猪肉碎 = 菜.切(菜.取食材("猪肉", 克(600)), "碎")
    洋葱丁 = 菜.切(菜.取食材("洋葱", 个(1)), "碎")
    番茄酱 = 菜.取食材("番茄酱", 克(100))

    return 菜.混合([芹菜段, 猪肉碎, 洋葱丁, 番茄酱],
                  "混合，下锅翻炒一分钟",
                  "意大利肉酱")

# 使用菜谱
处理器 = Markdown输出器()
意大利肉酱(处理器)
print(处理器.输出())
```

#### 2. 上下文管理器风格

```python
with 菜谱上下文(Markdown输出器()) as 菜:
    芹菜段 = 菜.切(菜.取食材("芹菜", 根(1)), "段")
    猪肉碎 = 菜.切(菜.取食材("猪肉", 克(600)), "碎")
    洋葱丁 = 菜.切(菜.取食材("洋葱", 个(1)), "碎")
    番茄酱 = 菜.取食材("番茄酱", 克(100))

    肉酱 = 菜.混合([芹菜段, 猪肉碎, 洋葱丁, 番茄酱],
                   "混合，下锅翻炒一分钟",
                   "意大利肉酱")
```

#### 3. 操作符重载风格

```python
处理器 = Markdown输出器()
菜 = 菜谱构建器(处理器)

# 使用 >> 操作符表示处理流程
芹菜段 = 菜.取食材("芹菜", 根(1)) >> 切("段")
猪肉碎 = 菜.取食材("猪肉", 克(600)) >> 切("碎")
洋葱丁 = 菜.取食材("洋葱", 个(1)) >> 切("碎")
番茄酱 = 菜.取食材("番茄酱", 克(100))

# 使用 + 表示混合
肉酱 = (芹菜段 + 猪肉碎 + 洋葱丁 + 番茄酱) >> 混合("混合，下锅翻炒一分钟")
```

### 菜谱复用

```python
@定义菜谱("意大利肉酱三明治")
def 意大利肉酱三明治(菜: 菜谱构建器):
    面包片 = 菜.取食材("面包片", 片(2))
    # 引用已定义的菜谱
    肉酱 = 菜.引用("意大利肉酱")

    return 菜.组合([面包片, 肉酱], "夹在一起", "意大利肉酱三明治")
```

### 组合处理器

```python
# 同时生成Markdown和统计
markdown_处理器 = Markdown输出器()
stats_处理器 = 统计分析器()
组合 = 组合处理器([markdown_处理器, stats_处理器])

# 执行菜谱
意大利肉酱三明治(组合)

# 输出结果
print(markdown_处理器.输出())
print(stats_处理器.输出())
```

## 核心概念

### 食材组件 (食材组件)

所有食材、中间产物、最终菜品都统一抽象为`食材组件`：

```python
组件 = 食材组件(
    name="土豆",
    数量=克(500),
    是否基础食材=True
)
```

### 数量类型

支持多种数量单位：

```python
克(500)      # 500克
个(2)        # 2个
片(3)        # 3片
根(1)        # 1根
毫升(100)    # 100毫升
自定义单位("1勺")  # 自定义描述
```

### 烹饪操作

支持多种烹饪操作：

```python
切("块")           # 切割
混合("拌匀")       # 混合
炒(30, "中火")     # 炒30秒
炖(120, "小火")    # 炖120秒
```

### 处理器

处理器负责将菜谱转换为不同的输出格式：

- **Markdown输出器**: 生成Markdown格式的烹饪步骤
- **统计分析器**: 统计食材用量
- **组合处理器**: 同时使用多个处理器

## 运行示例

```bash
# 基础示例
python 示例/基础示例.py

# 完整菜谱示例
python 示例/完整菜谱.py
```

## 框架结构

```
菜谱框架/
├── 核心组件.py       # 食材组件、数量类型、烹饪操作
├── 处理器.py         # 处理器协议和实现
├── 构建器.py         # 菜谱构建器
└── 装饰器.py         # 装饰器支持
```

## API对比

### 旧API (recipe_architecture.py) vs 新API

| 旧API | 新API |
|-------|-------|
| `Component(name)` | `食材组件(name)` |
| `factory.require(name, amount)` | `菜.取食材(name, amount)` 或 `菜[name, amount]` |
| `factory.process(comps, proc, name)` | `菜.处理(comps, proc, name)` |
| `Procedure.cut()` | `切制.切()` 或 `切()` |
| `MarkdownProcessor()` | `Markdown输出器()` |
| 函数式定义 | `@定义菜谱` 装饰器 |

## 设计优势

1. **统一抽象**: 一切皆食材组件
2. **高度可扩展**: 通过Protocol实现处理器
3. **强类型**: 完整的类型注解
4. **简洁**: 函数式风格，最小化冗余
5. **复用性**: 菜谱可以作为组件被其他菜谱引用
6. **Pythonic**: 充分利用Python特性

## 未来扩展

- [ ] 营养成分计算
- [ ] 时间估算
- [ ] 菜谱验证
- [ ] 并行执行优化
- [ ] 数据库持久化

## 贡献

欢迎提交Issue和Pull Request！

## 许可证

MIT License
