"""
处理器系统 - 菜谱处理器协议和实现
"""

from __future__ import annotations
from typing import Any, Dict, List, Optional, Protocol
from abc import ABC, abstractmethod

from .核心组件 import 食材组件, 数量类型, 烹饪操作


# ============================================================================
# 菜谱处理器协议 (Recipe Processor Protocol)
# ============================================================================

class 菜谱处理器(Protocol):
    """
    菜谱处理器协议

    定义了处理器的接口，使用Protocol实现鸭子类型。
    任何实现了这些方法的类都可以作为处理器使用。
    """

    def 取食材(self, 名称: str, 数量: 数量类型) -> 食材组件:
        """
        声明需要的食材

        参数:
            名称: 食材名称
            数量: 食材数量

        返回:
            食材组件对象
        """
        ...

    def 处理(
        self,
        组件: List[食材组件],
        操作: 烹饪操作,
        名称: str,
        **元数据
    ) -> 食材组件:
        """
        处理食材

        参数:
            组件: 要处理的食材组件列表
            操作: 烹饪操作
            名称: 处理后的名称
            **元数据: 额外的元数据

        返回:
            处理后的食材组件
        """
        ...


# ============================================================================
# Markdown输出器 (Markdown Processor)
# ============================================================================

class Markdown输出器:
    """
    Markdown输出处理器

    生成Markdown格式的烹饪步骤（干净版本，无冗余标记）
    """

    def __init__(self):
        self.操作列表: List[str] = []
        self._待处理食材: List[食材组件] = []  # 跟踪刚取出还未处理的食材

    def 取食材(self, 名称: str, 数量: 数量类型) -> 食材组件:
        """声明食材"""
        组件 = 食材组件(name=名称, 数量=数量, 是否基础食材=True)
        # 暂存食材，如果立即处理则不记录"取出"
        self._待处理食材.append(组件)
        return 组件

    def 处理(
        self,
        组件: List[食材组件],
        操作: 烹饪操作,
        名称: str,
        **元数据
    ) -> 食材组件:
        """处理食材"""
        # 创建新的组件
        新组件 = 食材组件(name=名称, 子组件=组件, 操作=操作)

        # 设置元数据
        if 元数据:
            for 键, 值 in 元数据.items():
                新组件 = 新组件.设置元数据(键, 值)

        # 先处理待处理食材（在生成描述之前）
        for 单个组件 in 组件:
            if 单个组件 in self._待处理食材:
                self._待处理食材.remove(单个组件)

        # 生成操作描述
        # 优化组件名称显示 - 去除中间产物名称中的下划线和后缀
        组件名称列表 = []
        for 单个组件 in 组件:
            名称 = 单个组件.name
            # 如果名称包含下划线（中间产物），提取原始名称
            if '_' in 名称 and not 单个组件.是否基础食材:
                # 提取原始名称（例如："姜_切片" -> "姜"）
                原始名称 = 名称.split('_')[0]
                组件名称列表.append(原始名称)
            else:
                组件名称列表.append(名称)

        if 操作.类型 == "cut":
            # 切割操作 - 合并"准备"和"切"，直接生成完整步骤
            if len(组件) == 1:
                原组件 = 组件[0]
                # 如果原组件有数量且是基础食材，直接显示"将X数量的Y切成Z"
                if 原组件.数量 and 原组件.是否基础食材:
                    描述 = f"将 {原组件.数量} 的 {原组件.name} {操作.描述}"
                else:
                    描述 = f"将 {原组件.name} {操作.描述}"
            else:
                描述 = f"将 {', '.join(组件名称列表)} {操作.描述}"

        elif 操作.类型 == "mix":
            # 混合操作
            描述 = f"将 {', '.join(组件名称列表)} {操作.描述}"

        elif 操作.类型 in ["fry", "stew"]:
            # 炒/炖操作
            描述 = f"将 {', '.join(组件名称列表)} {操作.描述}"

        else:
            # 其他操作
            描述 = f"将 {', '.join(组件名称列表)} {操作.描述}"

        self.操作列表.append(描述)
        return 新组件

    def 获取操作(self) -> List[str]:
        """获取所有操作"""
        return self.操作列表

    def 输出(self) -> str:
        """输出Markdown格式"""
        return "\n".join(self.操作列表)

    def 清空(self):
        """清空操作记录"""
        self.操作列表.clear()


# ============================================================================
# 统计分析器 (Statistics Processor)
# ============================================================================

class 统计分析器:
    """
    统计分析处理器

    收集和统计食材用量
    """

    def __init__(self):
        self.食材统计: Dict[str, Dict[str, float]] = {}

    def 取食材(self, 名称: str, 数量: 数量类型) -> 食材组件:
        """记录食材"""
        if 名称 not in self.食材统计:
            self.食材统计[名称] = {}

        if isinstance(数量.value, (int, float)):
            单位 = 数量.unit
            self.食材统计[名称][单位] = \
                self.食材统计[名称].get(单位, 0) + 数量.value

        return 食材组件(name=名称, 数量=数量, 是否基础食材=True)

    def 处理(
        self,
        组件: List[食材组件],
        操作: 烹饪操作,
        名称: str,
        **元数据
    ) -> 食材组件:
        """处理"""
        return 食材组件(name=名称, 子组件=组件, 操作=操作)

    def 获取统计(self) -> Dict[str, Dict[str, float]]:
        """获取统计数据"""
        return self.食材统计

    def 打印统计(self):
        """打印统计"""
        print("\n=== 食材统计 ===")
        for 名称, 数量字典 in self.食材统计.items():
            数量字符串 = " + ".join([f"{值}{键}" for 键, 值 in 数量字典.items()])
            print(f"- {名称}: {数量字符串}")

    def 输出(self) -> str:
        """输出统计信息"""
        行列表 = ["=== 食材统计 ==="]
        for 名称, 数量字典 in self.食材统计.items():
            数量字符串 = " + ".join([f"{值}{键}" for 键, 值 in 数量字典.items()])
            行列表.append(f"- {名称}: {数量字符串}")
        return "\n".join(行列表)


# ============================================================================
# 组合处理器 (Composite Processor)
# ============================================================================

class 组合处理器:
    """
    组合处理器

    同时委托给多个处理器，实现多种输出
    """

    def __init__(self, 处理器列表: List[菜谱处理器]):
        self.处理器列表 = 处理器列表

    def 取食材(self, 名称: str, 数量: 数量类型) -> 食材组件:
        """
        声明食材 - 委托给第一个处理器
        这样可以确保所有处理器使用相同的组件ID
        """
        if not self.处理器列表:
            raise ValueError("处理器列表为空")

        # 调用第一个处理器获取组件
        组件 = self.处理器列表[0].取食材(名称, 数量)

        # 通知其他处理器（如果它们需要记录）
        for 处理器 in self.处理器列表[1:]:
            处理器.取食材(名称, 数量)

        return 组件

    def 处理(
        self,
        组件: List[食材组件],
        操作: 烹饪操作,
        名称: str,
        **元数据
    ) -> 食材组件:
        """
        处理 - 委托给第一个处理器
        同样通知所有处理器
        """
        if not self.处理器列表:
            raise ValueError("处理器列表为空")

        # 调用第一个处理器
        结果组件 = self.处理器列表[0].处理(组件, 操作, 名称, **元数据)

        # 通知其他处理器
        for 处理器 in self.处理器列表[1:]:
            处理器.处理(组件, 操作, 名称, **元数据)

        return 结果组件

    def 获取子处理器(self, 索引: int) -> Optional[菜谱处理器]:
        """获取子处理器"""
        if 0 <= 索引 < len(self.处理器列表):
            return self.处理器列表[索引]
        return None

    def 获取所有输出(self) -> List[str]:
        """获取所有处理器的输出"""
        输出列表 = []
        for 处理器 in self.处理器列表:
            if hasattr(处理器, '输出'):
                输出列表.append(处理器.输出())
            elif hasattr(处理器, '获取操作'):
                输出列表.append("\n".join(处理器.获取操作()))
        return 输出列表
