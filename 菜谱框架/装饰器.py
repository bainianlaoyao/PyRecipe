"""
装饰器支持 - 提供装饰器来简化菜谱定义
"""

from __future__ import annotations
from typing import Any, Callable, Dict, Optional, TypeVar
from functools import wraps

from .核心组件 import 食材组件, 烹饪操作
from .构建器 import 菜谱构建器
from .处理器 import 菜谱处理器


T = TypeVar('T', bound=Callable[..., 食材组件])


# ============================================================================
# 菜谱注册表 (Recipe Registry)
# ============================================================================

class 菜谱注册表:
    """菜谱注册表 - 单例模式"""

    _实例: Optional["菜谱注册表"] = None
    _菜谱字典: Dict[str, Callable[..., 食材组件]] = {}

    def __new__(cls) -> "菜谱注册表":
        if cls._实例 is None:
            cls._实例 = super().__new__(cls)
        return cls._实例

    @classmethod
    def 注册(cls, 名称: str, 函数: Callable[..., 食材组件]):
        """注册菜谱"""
        cls._菜谱字典[名称] = 函数

    @classmethod
    def 获取(cls, 名称: str) -> Optional[Callable[..., 食材组件]]:
        """获取菜谱"""
        return cls._菜谱字典.get(名称)

    @classmethod
    def 列出(cls) -> list[str]:
        """列出所有菜谱"""
        return list(cls._菜谱字典.keys())

    @classmethod
    def 清空(cls):
        """清空注册表（主要用于测试）"""
        cls._菜谱字典.clear()


# ============================================================================
# 装饰器
# ============================================================================

def 定义菜谱(名称: str):
    """
    定义菜谱装饰器

    使用方式:
        @定义菜谱("意大利肉酱")
        def 意大利肉酱(菜: 菜谱构建器):
            芹菜段 = 菜.切("芹菜", 根(1), "段")
            猪肉碎 = 菜.切("猪肉", 克(600), "碎")
            洋葱丁 = 菜.切("洋葱", 个(1), "碎")
            番茄酱 = 菜.取食材("番茄酱", 克(100))

            return 菜.混合([芹菜段, 猪肉碎, 洋葱丁, 番茄酱],
                          "混合，下锅翻炒一分钟")

    参数:
        名称: 菜谱名称
    """
    def 装饰器(函数: T) -> T:
        @wraps(函数)
        def 包装器(处理器_或构建器, *参数, **关键字参数) -> 食材组件:
            # 检查传入的是处理器还是构建器
            if isinstance(处理器_或构建器, 菜谱构建器):
                # 已经是构建器，直接使用
                构建器 = 处理器_或构建器
            else:
                # 是处理器，创建构建器
                构建器 = 菜谱构建器(处理器_或构建器)
            return 函数(构建器, *参数, **关键字参数)

        # 注册到菜谱注册表
        菜谱注册表.注册(名称, 包装器)

        return 包装器  # type: ignore
    return 装饰器


def 简化菜谱(名称: str):
    """
    简化菜谱装饰器 - 不需要处理器参数

    使用方式:
        @简化菜谱("炒土豆")
        def 炒土豆():
            # 使用全局处理器
            ...

    参数:
        名称: 菜谱名称
    """
    def 装饰器(函数: T) -> T:
        @wraps(函数)
        def 包装器(处理器_或构建器 = None, *参数, **关键字参数) -> 食材组件:
            if 处理器_或构建器 is None:
                # 使用默认处理器
                from .处理器 import Markdown输出器
                处理器_或构建器 = Markdown输出器()

            # 检查传入的是处理器还是构建器
            if isinstance(处理器_或构建器, 菜谱构建器):
                构建器 = 处理器_或构建器
            else:
                构建器 = 菜谱构建器(处理器_或构建器)

            return 函数(构建器, *参数, **关键字参数)

        菜谱注册表.注册(名称, 包装器)
        return 包装器  # type: ignore
    return 装饰器


def 批量定义(名称列表: list[str]):
    """
    批量定义多个菜谱

    使用方式:
        @批量定义(["菜谱1", "菜谱2", "菜谱3"])
        class 菜谱集合:
            @staticmethod
            def 菜谱1(菜: 菜谱构建器):
                ...

            @staticmethod
            def 菜谱2(菜: 菜谱构建器):
                ...

    参数:
        名称列表: 菜谱名称列表
    """
    def 装饰器(类: type) -> type:
        for 名称 in 名称列表:
            if hasattr(类, 名称):
                函数 = getattr(类, 名称)
                菜谱注册表.注册(名称, 函数)
        return 类
    return 装饰器


# ============================================================================
# 上下文管理器
# ============================================================================

from contextlib import contextmanager


@contextmanager
def 菜谱上下文(处理器: 菜谱处理器):
    """
    菜谱上下文管理器

    使用方式:
        with 菜谱上下文(Markdown输出器()) as 菜:
            芹菜段 = 菜.切("芹菜", 根(1), "段")
            猪肉碎 = 菜.切("猪肉", 克(600), "碎")
            ...

    参数:
        处理器: 菜谱处理器实例

    返回:
        菜谱构建器实例
    """
    构建器 = 菜谱构建器(处理器)
    try:
        yield 构建器
    finally:
        # 可以在这里执行清理操作
        pass


# ============================================================================
# 便利函数
# ============================================================================

def 执行菜谱(名称: str, 处理器: 菜谱处理器) -> 食材组件:
    """
    执行已注册的菜谱

    参数:
        名称: 菜谱名称
        处理器: 菜谱处理器

    返回:
        食材组件

    异常:
        ValueError: 如果菜谱不存在
    """
    函数 = 菜谱注册表.获取(名称)
    if 函数 is None:
        raise ValueError(f"菜谱 '{名称}' 不存在")
    return 函数(处理器)


def 引用菜谱(名称: str) -> Callable[[菜谱处理器], 食材组件]:
    """
    创建菜谱引用函数

    使用方式:
        @定义菜谱("主菜")
        def 主菜(菜: 菜谱构建器):
            子菜 = 菜.引用("意大利肉酱")
            ...

    参数:
        名称: 要引用的菜谱名称

    返回:
        接收处理器的函数
    """
    def 引用(处理器: 菜谱处理器) -> 食材组件:
        return 执行菜谱(名称, 处理器)
    return 引用


# 为菜谱构建器添加引用方法
原初始化 = 菜谱构建器.__init__

def 新初始化(self, 处理器: 菜谱处理器):
    原初始化(self, 处理器)

    # 添加引用方法
    def 引用方法(名称: str) -> 食材组件:
        return 执行菜谱(名称, self.处理器)

    self.引用 = 引用方法  # type: ignore


菜谱构建器.__init__ = 新初始化
